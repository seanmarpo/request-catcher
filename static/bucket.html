<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Viewing Bucket - Web Request Catcher</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
            rel="stylesheet"
        />
        <style>
            body {
                font-family: "Inter", sans-serif;
            }
            pre {
                box-sizing: border-box;
            }
        </style>
        <script>
            // Apply dark mode based on system preference
            if (
                window.matchMedia &&
                window.matchMedia("(prefers-color-scheme: dark)").matches
            ) {
                document.documentElement.classList.add("dark");
            }
        </script>
    </head>
    <body class="bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-100">
        <div class="container mx-auto p-4">
            <div
                class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md mb-6 flex justify-between items-center"
            >
                <div>
                    <h1 class="text-2xl font-bold">
                        Viewing Bucket: <span id="bucket-name-display"></span>
                    </h1>
                    <p
                        class="text-sm text-gray-500 dark:text-gray-400 mt-2 flex items-center gap-2"
                    >
                        Send requests to:
                        <code
                            id="capture-url"
                            class="bg-gray-200 dark:bg-gray-700 p-1 rounded"
                        ></code>
                        <button
                            id="copy-url-btn"
                            class="bg-gray-500 hover:bg-gray-600 text-white text-xs px-2 py-1 rounded-md"
                            title="Copy URL"
                        >
                            Copy
                        </button>
                    </p>
                </div>
                <div class="flex space-x-2">
                    <button
                        id="share-btn"
                        class="bg-indigo-500 text-white px-4 py-2 rounded-md hover:bg-indigo-600"
                    >
                        Share
                    </button>
                    <a
                        href="/ui/"
                        class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600"
                        >Create Another Bucket</a
                    >
                    <button
                        id="clear-requests-btn"
                        class="bg-yellow-500 text-white px-4 py-2 rounded-md hover:bg-yellow-600"
                    >
                        Clear Requests
                    </button>
                    <button
                        id="delete-bucket-btn"
                        class="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600"
                    >
                        Delete Bucket
                    </button>
                </div>
            </div>

            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold">Captured Requests</h2>
                    <div class="flex items-center space-x-2">
                        <div
                            id="polling-indicator"
                            class="w-3 h-3 bg-gray-400 rounded-full"
                            title="Polling inactive"
                        ></div>
                        <span class="text-sm text-gray-600 dark:text-gray-400"
                            >Polling...</span
                        >
                    </div>
                </div>
                <div id="requestsContainer" class="space-y-4">
                    <p>Waiting for the first request...</p>
                </div>
            </div>
        </div>

        <script>
            (() => {
                // DOM element cache
                const elements = {};

                // State management
                const state = {
                    bucketName: null,
                    password: null,
                    pollInterval: null,
                    collapsedRequests: new Set(),
                    expandedBodies: new Set(),
                };

                // Helper: Create element with class and optional text
                function createElement(tag, className, textContent = null) {
                    const el = document.createElement(tag);
                    if (className) el.className = className;
                    if (textContent) el.textContent = textContent;
                    return el;
                }

                // Helper: Generate unique hash for request
                function getRequestHash(req) {
                    return `${req.timestamp}|${req.method}|${req.path}`;
                }

                // Helper: Copy to clipboard with feedback
                async function copyToClipboard(text, button, originalText) {
                    try {
                        await navigator.clipboard.writeText(text);
                        button.textContent = "Copied!";
                        setTimeout(() => {
                            button.textContent = originalText;
                        }, 2000);
                    } catch (err) {
                        console.error("Could not copy text:", err);
                        alert("Failed to copy. Please copy manually.");
                    }
                }

                // Helper: Update polling indicator status
                function updatePollingIndicator(status, message) {
                    const indicator = elements.pollingIndicator;
                    indicator.classList.remove(
                        "animate-pulse",
                        "bg-green-500",
                        "bg-red-500",
                    );

                    if (status === "active") {
                        indicator.classList.add("bg-green-500");
                        indicator.title =
                            message ||
                            `Polling active. Last check: ${new Date().toLocaleTimeString()}`;
                    } else if (status === "error") {
                        indicator.classList.add("bg-red-500");
                        indicator.title = message || "Polling error";
                    } else if (status === "loading") {
                        indicator.classList.add("animate-pulse");
                    }
                }

                // Build query parameters section
                function buildQueryParamsSection(queryParams) {
                    if (!queryParams || Object.keys(queryParams).length === 0) {
                        return null;
                    }

                    const queryDiv = createElement("div", "mt-2");
                    const queryTitle = createElement(
                        "h4",
                        "font-medium text-sm",
                        "Query Parameters:",
                    );
                    queryDiv.appendChild(queryTitle);

                    const queryList = createElement(
                        "ul",
                        "list-disc list-inside text-sm",
                    );
                    for (const [key, value] of Object.entries(queryParams)) {
                        const item = createElement("li");
                        const strong = createElement(
                            "strong",
                            null,
                            `${key}: `,
                        );
                        item.appendChild(strong);
                        item.appendChild(document.createTextNode(value));
                        queryList.appendChild(item);
                    }
                    queryDiv.appendChild(queryList);
                    return queryDiv;
                }

                // Build headers section
                function buildHeadersSection(headers) {
                    const headersDiv = createElement("div", "mt-2");
                    const headersTitle = createElement(
                        "h4",
                        "font-medium text-sm",
                        "Headers:",
                    );
                    headersDiv.appendChild(headersTitle);

                    const headersList = createElement(
                        "ul",
                        "list-disc list-inside text-sm",
                    );
                    for (const [key, value] of Object.entries(headers)) {
                        const item = createElement("li");
                        const strong = createElement(
                            "strong",
                            null,
                            `${key}: `,
                        );
                        item.appendChild(strong);
                        item.appendChild(document.createTextNode(value));
                        headersList.appendChild(item);
                    }
                    headersDiv.appendChild(headersList);
                    return headersDiv;
                }

                // Build body section
                function buildBodySection(req, requestHash, index) {
                    const bodyDiv = createElement("div", "mt-2");
                    const bodyTitle = createElement(
                        "h4",
                        "font-medium text-sm",
                        "Body:",
                    );
                    bodyDiv.appendChild(bodyTitle);

                    const bodyText = req.body || "No body";
                    const bodyLength = bodyText.length;
                    const isBinary = /[\x00-\x08\x0E-\x1F]/.test(bodyText);

                    if (bodyLength > 1000 || isBinary) {
                        // Add body info
                        const bodyInfo = createElement(
                            "p",
                            "text-xs text-gray-600 dark:text-gray-400 mb-1",
                            isBinary
                                ? `Binary data (${bodyLength.toLocaleString()} bytes) - likely a file upload`
                                : `Large body (${bodyLength.toLocaleString()} characters)`,
                        );
                        bodyDiv.appendChild(bodyInfo);

                        if (isBinary) {
                            // Binary data message
                            const binaryMsg = createElement(
                                "div",
                                "bg-gray-200 dark:bg-gray-600 p-2 rounded-md text-xs italic",
                                "Binary content not displayed",
                            );
                            bodyDiv.appendChild(binaryMsg);
                        } else {
                            // Large text with expand/collapse
                            const bodyContainer = createElement(
                                "div",
                                "relative",
                            );
                            const isExpanded =
                                state.expandedBodies.has(requestHash);

                            const bodyWrapper = createElement(
                                "div",
                                "bg-gray-200 dark:bg-gray-600 rounded-md",
                            );
                            bodyWrapper.id = `body-wrapper-${index}`;
                            bodyWrapper.style.display = isExpanded
                                ? "block"
                                : "none";
                            bodyWrapper.style.maxHeight = isExpanded
                                ? "24rem"
                                : "0";
                            bodyWrapper.style.overflowY = isExpanded
                                ? "auto"
                                : "hidden";

                            const bodyPre = createElement(
                                "pre",
                                "p-2 whitespace-pre-wrap text-xs break-words",
                                bodyText,
                            );
                            bodyPre.style.margin = "0";
                            bodyWrapper.appendChild(bodyPre);
                            bodyContainer.appendChild(bodyWrapper);

                            const expandBtn = createElement(
                                "button",
                                "mt-1 text-xs text-blue-600 dark:text-blue-400 hover:underline",
                                isExpanded ? "Hide body" : "Show body",
                            );
                            expandBtn.id = `expand-body-${index}`;
                            expandBtn.addEventListener("click", (e) => {
                                e.stopPropagation();
                                const wrapper = document.getElementById(
                                    `body-wrapper-${index}`,
                                );
                                const btn = document.getElementById(
                                    `expand-body-${index}`,
                                );

                                const isCurrentlyHidden =
                                    wrapper.style.display === "none";
                                wrapper.style.display = isCurrentlyHidden
                                    ? "block"
                                    : "none";
                                wrapper.style.maxHeight = isCurrentlyHidden
                                    ? "24rem"
                                    : "0";
                                wrapper.style.overflowY = isCurrentlyHidden
                                    ? "auto"
                                    : "hidden";
                                btn.textContent = isCurrentlyHidden
                                    ? "Hide body"
                                    : "Show body";

                                if (isCurrentlyHidden) {
                                    state.expandedBodies.add(requestHash);
                                } else {
                                    state.expandedBodies.delete(requestHash);
                                }
                            });

                            bodyContainer.appendChild(expandBtn);
                            bodyDiv.appendChild(bodyContainer);
                        }
                    } else {
                        // Small body - show normally
                        const bodyPre = createElement(
                            "pre",
                            "bg-gray-200 dark:bg-gray-600 p-2 rounded-md whitespace-pre-wrap text-xs break-words",
                            bodyText,
                        );
                        bodyDiv.appendChild(bodyPre);
                    }

                    return bodyDiv;
                }

                // Build a single request element
                function buildRequestElement(req, index) {
                    const requestHash = getRequestHash(req);
                    const reqElement = createElement(
                        "div",
                        "border dark:border-gray-600 rounded-md bg-gray-50 dark:bg-gray-700 overflow-hidden mb-2",
                    );

                    // Header section (collapsible trigger)
                    const headerSection = createElement(
                        "div",
                        "p-2 bg-gray-100 dark:bg-gray-600 cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-500 flex justify-between items-center",
                    );
                    const headerLeft = createElement("div");
                    const titleEl = createElement(
                        "h3",
                        "font-semibold text-sm",
                        `${req.method} ${req.path}`,
                    );
                    headerLeft.appendChild(titleEl);
                    headerSection.appendChild(headerLeft);

                    // Expand/collapse indicator
                    const isCollapsed =
                        state.collapsedRequests.has(requestHash);
                    const indicator = createElement(
                        "span",
                        "text-gray-500 font-bold",
                        isCollapsed ? "▶" : "▼",
                    );
                    indicator.id = `indicator-${index}`;
                    headerSection.appendChild(indicator);
                    reqElement.appendChild(headerSection);

                    // Details section
                    const detailsSection = createElement("div", "p-3");
                    detailsSection.id = `details-${index}`;
                    detailsSection.style.display = isCollapsed
                        ? "none"
                        : "block";

                    // Full path
                    const pathEl = createElement(
                        "p",
                        "text-sm text-gray-600 dark:text-gray-300",
                    );
                    pathEl.textContent = "Full Path: ";
                    const pathCodeEl = createElement(
                        "code",
                        "bg-gray-200 dark:bg-gray-600 p-1 rounded text-xs",
                    );
                    let fullPath = req.path;
                    if (
                        req.query_params &&
                        Object.keys(req.query_params).length > 0
                    ) {
                        const queryString = Object.entries(req.query_params)
                            .map(([key, value]) => `${key}=${value}`)
                            .join("&");
                        fullPath = `${req.path}?${queryString}`;
                    }
                    pathCodeEl.textContent = fullPath;
                    pathEl.appendChild(pathCodeEl);
                    detailsSection.appendChild(pathEl);

                    // Query parameters
                    const querySection = buildQueryParamsSection(
                        req.query_params,
                    );
                    if (querySection) {
                        detailsSection.appendChild(querySection);
                    }

                    // Headers
                    detailsSection.appendChild(
                        buildHeadersSection(req.headers),
                    );

                    // Body
                    detailsSection.appendChild(
                        buildBodySection(req, requestHash, index),
                    );

                    reqElement.appendChild(detailsSection);

                    // Toggle handler
                    headerSection.addEventListener("click", () => {
                        const details = document.getElementById(
                            `details-${index}`,
                        );
                        const indicator = document.getElementById(
                            `indicator-${index}`,
                        );

                        if (details.style.display === "none") {
                            details.style.display = "block";
                            indicator.textContent = "▼";
                            state.collapsedRequests.delete(requestHash);
                        } else {
                            details.style.display = "none";
                            indicator.textContent = "▶";
                            state.collapsedRequests.add(requestHash);
                        }
                    });

                    return reqElement;
                }

                // Fetch and display requests
                async function fetchAndDisplayRequests() {
                    updatePollingIndicator("loading");

                    try {
                        const response = await fetch(
                            `/api/requests/${state.bucketName}`,
                            {
                                headers: {
                                    "X-Bucket-Password": state.password,
                                },
                            },
                        );

                        if (!response.ok) {
                            clearInterval(state.pollInterval);
                            updatePollingIndicator(
                                "error",
                                "Authentication error",
                            );

                            const errorText = await response.text();
                            const errorPara = createElement(
                                "p",
                                "text-red-500",
                            );
                            const strongEl = createElement(
                                "strong",
                                null,
                                "Error fetching requests:",
                            );
                            errorPara.appendChild(strongEl);
                            errorPara.appendChild(
                                document.createTextNode(
                                    ` ${errorText} (Status: ${response.status}). Polling has stopped.`,
                                ),
                            );
                            elements.requestsContainer.replaceChildren(
                                errorPara,
                            );
                            return;
                        }

                        const requests = await response.json();
                        updatePollingIndicator("active");

                        if (requests.length === 0) {
                            const noRequestsMsg = createElement(
                                "p",
                                null,
                                "No requests captured yet.",
                            );
                            elements.requestsContainer.replaceChildren(
                                noRequestsMsg,
                            );
                        } else {
                            // Build all request elements
                            const fragment = document.createDocumentFragment();
                            requests.reverse().forEach((req, index) => {
                                fragment.appendChild(
                                    buildRequestElement(req, index),
                                );
                            });
                            elements.requestsContainer.replaceChildren(
                                fragment,
                            );
                        }
                    } catch (error) {
                        console.error("Error:", error);
                        updatePollingIndicator("error", "Network error");

                        const errorPara = createElement(
                            "p",
                            "text-red-500",
                            "An error occurred while fetching requests. Check the console.",
                        );
                        elements.requestsContainer.replaceChildren(errorPara);
                    }
                }

                // Clear all requests
                async function clearRequests() {
                    if (
                        !confirm(
                            `Are you sure you want to clear all requests from bucket "${state.bucketName}"?`,
                        )
                    ) {
                        return;
                    }

                    try {
                        const response = await fetch(
                            `/api/clear/${state.bucketName}`,
                            {
                                method: "POST",
                                headers: {
                                    "X-Bucket-Password": state.password,
                                },
                            },
                        );

                        if (response.ok) {
                            fetchAndDisplayRequests();
                        } else {
                            const errorText = await response.text();
                            alert(`Error clearing requests: ${errorText}`);
                        }
                    } catch (error) {
                        console.error("Error clearing requests:", error);
                        alert("An error occurred while clearing requests.");
                    }
                }

                // Delete bucket
                async function deleteBucket() {
                    if (
                        !confirm(
                            `Are you sure you want to delete the bucket "${state.bucketName}"? This action cannot be undone.`,
                        )
                    ) {
                        return;
                    }

                    try {
                        const response = await fetch(
                            `/api/delete/${state.bucketName}`,
                            {
                                method: "DELETE",
                                headers: {
                                    "X-Bucket-Password": state.password,
                                },
                            },
                        );

                        if (response.ok) {
                            alert(
                                `Bucket "${state.bucketName}" was successfully deleted.`,
                            );
                            window.location.href = "/ui/";
                        } else {
                            const errorText = await response.text();
                            alert(`Error deleting bucket: ${errorText}`);
                        }
                    } catch (error) {
                        console.error("Error deleting bucket:", error);
                        alert("An error occurred while deleting the bucket.");
                    }
                }

                // Initialize the application
                function init() {
                    // Cache DOM elements
                    elements.bucketNameDisplay = document.getElementById(
                        "bucket-name-display",
                    );
                    elements.captureUrl =
                        document.getElementById("capture-url");
                    elements.requestsContainer =
                        document.getElementById("requestsContainer");
                    elements.pollingIndicator =
                        document.getElementById("polling-indicator");
                    elements.shareBtn = document.getElementById("share-btn");
                    elements.clearRequestsBtn =
                        document.getElementById("clear-requests-btn");
                    elements.deleteBucketBtn =
                        document.getElementById("delete-bucket-btn");
                    elements.copyUrlBtn =
                        document.getElementById("copy-url-btn");

                    // Get bucket info from URL
                    const urlParams = new URLSearchParams(
                        window.location.search,
                    );
                    state.bucketName = urlParams.get("name");
                    state.password = urlParams.get("password");

                    // Validate bucket info
                    if (!state.bucketName || !state.password) {
                        const errorMsg = createElement(
                            "p",
                            "text-red-500 font-bold",
                            "Error: Bucket name or password not provided in the URL.",
                        );
                        elements.requestsContainer.replaceChildren(errorMsg);
                        return;
                    }

                    // Set bucket name and URL
                    elements.bucketNameDisplay.textContent = state.bucketName;
                    const captureUrlText = `${window.location.origin}/${state.bucketName}`;
                    elements.captureUrl.textContent = captureUrlText;

                    // Set up event listeners
                    elements.copyUrlBtn.addEventListener("click", () => {
                        copyToClipboard(
                            captureUrlText,
                            elements.copyUrlBtn,
                            "Copy",
                        );
                    });

                    elements.shareBtn.addEventListener("click", () => {
                        copyToClipboard(
                            window.location.href,
                            elements.shareBtn,
                            "Share",
                        );
                    });

                    elements.clearRequestsBtn.addEventListener(
                        "click",
                        clearRequests,
                    );
                    elements.deleteBucketBtn.addEventListener(
                        "click",
                        deleteBucket,
                    );

                    // Start polling
                    fetchAndDisplayRequests();
                    state.pollInterval = setInterval(
                        fetchAndDisplayRequests,
                        3000,
                    );
                }

                // Start when DOM is ready
                document.addEventListener("DOMContentLoaded", init);
            })();
        </script>
    </body>
</html>
